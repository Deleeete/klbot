# KLBot模块开发规范 - 初版
### ---- 此规范版本适用于核心库（klbotlib） v0.5+
### ---- **逻辑上建议从第二部分开始阅读，第一部分放在最前只是因为要方便查阅规范**

<br>

## 一、模块开发的最最最基本的规范
1. **任何新功能**都要通过模块实现。

2. 模块以**类**的形式定义，且需要继承`Module`基类，并在`klbotlib.Modules`命名空间中实现。模块的名称（类名）必须以“Module”结尾。

> 例如，想开发一个命令模块，可以定义一个`klbotlib.Modules.CommandModule`类。

> *此规定旨在借助编译器保证模块之间不会有重名问题，从而方便通过类名利用反射直接对模块进行操作。*

3. 开发某个模块时额外定义的所有类都应该定义在`klbotlib.Modules.[相应的模块类名]Namespace`命名空间中。

> 例如，假设开发命令模块`CommandModule`时要辅助定义`Command`类，则应该把`Command`类定义在`klbotlib.Modules.CommandModuleNamespace`这个命名空间里。

> *此规定旨在保证为不同模块额外定义的类不会引发命名冲突。*

4. 单个模块的实现应该尽量在**同一个**.cs文件中完成，且命名为`模块类名.cs`，并放在`src/modules`文件夹里。
如果因为内容太多做不到或者不想这样，而想分成多个文件存放，则应在`src/modules`目录创建文件夹`模块类名`并把相关文件统一放在这个文件夹里。
**另一方面，即使选择拆分成多个文件，模块的主类仍然应该定义在文件 `模块类名.cs` 里。这个和1、2、3点一样是强制要求**。

> 例如，假设开发命令模块`CommandModule`时想分成两个文件存放，则应该新建文件夹`src/modules/CommandModule`，然后把这两个文件放在里面。**其中，主类`CommandModule`所在的文件应该命名为`CommandModule.cs`。**

> *此规定旨在保证源码文件组织有序。*

5. 开发过程中，只修改“src/modules”目录下的源码。modules文件夹外的源码是KLBot的基础设施。只有KLBot版本迭代才会涉及到对这些文件的修改。

6. 开发过程中，只修改自己正在开发的模块的源码，除非迫不得已。即使你的功能必须涉及对其他模块代码的修改，也必须先和所修改模块的开发者沟通。最好的情况是他能帮你完成有关工作。

> 目前仅有的三个默认模块`CommandModule`、`FuckModule`和`ChatQYKModule`由我负责。

> *此规定（以及整个模块化架构）旨在保证每个人自己写的东西不会被其他人瞎寄吧乱改。*

7. 每个模块都有自己的**缓存目录**，这个目录可以通过调用Bot实例的`GetModuleCacheDir(Module module)`函数得到。当需要读写文件时，模块应该通过自身的`SaveFileAsString()`和`ReadFileAsString()`（读写文本文件）或者`SaveFileAsBinary()`和`ReadFileAsBinary()`（读写二进制文件）来安全地完成读写操作。**不要用`System.IO.File`类**。 调用这两个函数来存取文件可以保证产生的所有文件都在私有目录下。

> *此规定可以确保模块不会在服务器上的文件系统上随地排泄自己的文件，引发各种潜在的冲突乃至安全问题。*

8. 当模块需要在控制台打印内容时，不要用`System.Console`类。用模块自己的`ModulePrint()`方法。**尽量在最后一个参数里声明内容的级别（Task, Info, Warning或者Error）**。

> *这可以帮助KLBot实例的管理者确定每条消息的来源模块，方便问题的发现与调试，并保证控制台输出格式整齐。*

<br>

### 上述规范的一个不完整例子：命令模块`CommandModule`

命令模块`CommandModule`的源码文件应该为`“CommandModule.cs”`，且其内容结构应该类似：

```CSharp
//引用专门用来定义辅助类的命名空间
using klbotlib.Modules.CommandModuleNamespace;	

//所有模块都应该在此命名空间中定义
namespace klbotlib.Modules	
{  
    public class CommandModule : Module
    {
        //模块的实现
    }
}

//为这个模块服务的其他辅助类应该在此命名空间中定义
namespace klbotlib.Modules.CommandModuleNamespace	
{
    public class Command
    {
        //Command类的实现
    }
}
```

如果不像上面的例子一样在同一个文件中完成，则可以将`CommandModuleNamespace`命名空间中的内容拆分到一个或多个.cs文件中，但是`CommandModule`类仍然需要定义在`“CommandModule.cs”`文件里。

到目前为止整不明白也没关系，下面（第四部分）有更详细的例子。

<hr>
<br>

## 二、认识KLBot的架构，从而理解模块开发的核心内容
### 0. 项目结构简介
整个KLBot项目分为两个部分。一个是exe项目`klbot`，另一个是核心库项目`klbotlib`。

核心库`klbotlib`包含了运行一个KLBot实例所需的完整实现，所有功能都是写在这个项目里。

可执行项目`klbot`只是调用了`klbotlib`库，然后在控制台里运行一个KLBot实例（外加一些外围的简单异常处理），从而组成一个能运行的程序（KLG-苍白嘴臭蓝人的本体就是这个`klbot`项目）。

显然，模块开发只需要操心`klbotlib`项目就可以了。


<br>

### 1. 了解最基础的几个类型
`KLBot`类是机器人的主体，负责执行消息的收发和处理。所有最顶层的操作都由它来完成。

`Message`基类是机器人所处理信息的载体，也就是QQ消息。**所有类型的QQ消息都继承`Message`基类**，但是因为还没有开发处理图像的模块，目前这个基类下只定义了纯文本消息`MessagePlain`类。

`Module`类，也就是前面说的**模块**，是机器人功能实现的基本单位。简单来说，模块接收一条`Message`，处理，然后返回一个输出字符串。

认识`KLBot`的消息处理机制暂时只需要知道这三个类。

<br>

### 2. KLBot的消息处理机制
一个`KLBot`对象包含了一系列**有先后顺序**的模块，这些模块保存在`KLBot.Modules`字段里，下面不妨把它叫做这个Bot的“模块链条”。粗略来说，Bot接收到的新消息会从这个链条的最前端，一步一步向链条的末端传递。而**模块在模块链条中的顺序，取决于它添加进模块链条时的顺序。**

> 这个顺序是由调用KLBot的构造函数时传进去的参数决定的。原因下面会说。

当这个Bot接收到一系列`Message`时，这一系列`Message`会被喂给模块链条里的每一个模块，顺序是从先到后。

每个模块接收到这一堆`Message`对象时，首先会用自己的`Filter(Message msg)`函数过滤掉一部分，这部分消息不做处理，然后用自己的`Process(Message msg)`函数处理剩下的部分，并返回一个输出字符串。**这个输出字符串会被KLBot拿到**。

接下来，取决于这个模块是否是**透明模块**，它可能会-也可能不会，把消息传递给模块链条中的下一个模块：

对于透明模块而言，`Module.IsTransparent=true`，顾名思义，所有处理或未处理的消息都会被继续传递给下一个模块，对后续所有模块而言，这个模块相当于不存在；

对于非透明模块而言，`Module.IsTransparent=false`，只有一开始被过滤掉的那些未处理的消息会被传递给下一个模块，而没被处理的消息会直接被原地吞掉。

由于这种机制，不难看出，在模块列表中越靠前的模块，处理消息的优先级越高。如果一条消息被第n个（不透明的）模块处理，那么任何排位>n的模块都无法知道该消息的存在。

> 这个优先级不能也不应该由模块开发者决定，因为即使允许同优先级模块存在，没有经过协调的优先级也很可能导致一些模块不能正确处理到想处理的消息。

> 举个极端的例子，一个会处理**所有消息**的不透明模块，如果被放在消息链条最前面的位置，也就是最高优先级，显然会导致剩下所有模块都直接抓瞎。

> 因此，优先级被设计为由调用KLBot的构造函数时传进去的参数决定，这样所有模块的先后顺序可以由创建KLBot实例的人全权负责。考虑到KLBot实例管理者一定明确知道自己想做什么，从而必然了解每个要用到的模块的基本功能，这是更合理的选择。

> 因此，**如果想调整你的模块的优先级，找KLBot实例的使用者修改KLBot的构造函数调用参数**（通常并不需要这么做，因为优先级实际上本来就只是KLBot实例管理者的事情，模块开发者只管写模块就好）。

最后，KLBot拿到模块的输出字符串后，会判断其内容是否为空或null。根据约定，如果为空则意味着模块不做输出，因此Bot将继续干别的活。否则，KLBot会向**相应消息的源头**回复这个字符串。

<br>

### 3. 模块开发的核心
理解了上面所说的消息处理机制，就很容易看出模块开发的核心内容：分别实现`Filter(Message msg)`方法和`Process(Message msg)`方法。其中，前者决定了这个模块**应当处理哪些消息**，后者决定了这个模块**怎么处理这些消息**。

实际开发中，只需要让你的模块继承``Module``基类，编译器会强迫你实现这两个抽象方法。

<hr>
<br>

## 三、模块开发的详细文档
### 1. `Module`类的成员定义和详解

```CSharp
    public abstract class Module
    {
        //模块名. 是模块种类的唯一标识. 直接等于模块在源码中的类名.
        //模块开发者不需要操心这个字段
        public string ModuleName { get => GetType().Name; } 

        //模块ID. 是同一个KLBot中每个模块对象的唯一标识. 等于“模块类名[在同类模块中的排位]”
        //同上，不需要操心
        public string ModuleID { get; set; }

        // 模块的总开关. 默认开启
        // 如果关掉的话，这个模块就会忽略所有传入的消息（并且传给下一个模块）
        [ModuleStatus]    //这个ModuleStatus是一个Attribute，之后会解释
        public bool Enabled { get; set; } = true;

        // 决定此模块是否是透明模块(默认为不透明(false))。这个东西的意义上面已经说过了。
        // 简单来说，如果你希望自己的模块把处理过的消息全部挡下来独占，就不用管这个字段；
        // 否则用override关键字把它设置为true。
        public virtual bool IsTransparent { get; } = false;

        // 决定KLBot在发送此模块的消息时是否在前面附上此模块的签名“[模块ID]”（默认为是(true)）
        // 比如，如果模块CommandModule[1]将这个值设置为true，则机器人在返回这个模块的输出时会在最前面加上“[CommandModule[0]]”
        // 这样，使用者就能知道是这条消息是哪个模块的处理结果
        // 为了方便，尽量不要修改这个值为false，除非这个附加签名确实影响模块的使用体验（比如在聊天模块的场景里）。
        // 如果确实不希望附上这个签名，用override关键字把它设置为false即可。
        public virtual bool UseSignature { get; } = true;

        // 过滤器(Message -> bool). 模块通过这个函数判断是否要处理某一条消息. 
        // 当模块总开关开启时，结果为true的消息会被处理，结果为false的消息会被忽略.
        public abstract bool Filter(Message msg);

        // 处理器(Message -> string). 模块通过这个函数处理所有(通过了过滤器的)消息. 
        public abstract string Processor(Message msg);

        // 这个函数综合了过滤器和开关的影响, 返回一条消息是否应被处理
        public bool ShouldProcess(Message msg) => Enabled && Filter(msg);

        // 模块所属的Bot。用来让模块有办法访问KLBot实例和它的成员
        // 但是模块开发规范不鼓励直接访问KLBot实例。
        // 在写下类似“HostBox.****”的代码前，尽量确保这是无法避免的
        public KLBot HostBot { get; }

        // 无趣的构造函数
        public Module(KLBot host_bot);

        //这个函数用来读取模块配置和模块状态的存档。模块开发不大可能用到。
        //把一个字典的值自动导入模块里标记了[ModuleStatus]或者[ModuleSetup]的字段。
        //再次，这个[ModuleStatus]和[ModuleSetup]具体是什么之后会解释。
        public void ImportDict(Dictionary<string, object> status_dict);

        // 这个函数用来保存模块状态。同样，模块开发不大可能用到。
        // 把此模块的所有模块状态([ModuleStatus])导出到字典
        public Dictionary<string, object> ExportStatusDict() => ExportMemberWithAttribute(typeof(ModuleStatusAttribute));

        // 把此模块的所有模块配置([ModuleStatus])导出到字典
        // 这个函数用来保存模块配置
        public Dictionary<string, object> ExportSetupDict() => ExportMemberWithAttribute(typeof(ModuleSetupAttribute));


        // 存读模块自定义文件。按照规范，这两个是模块存读文件的标准方法。
        // 如果你要存取文件，必须用这四个方法。
        /// 保存文本到模块缓存目录
        public void SaveFileAsString(string relative_path, string text);
        /// 保存二进制到模块缓存目录
        public void SaveFileAsBinary(string relative_path, byte[] bin);
        /// 从模块缓存目录里读取文本
        public string ReadFileAsString(string relative_path);
        /// 从模块缓存目录里读取二进制
        public byte[] ReadFileAsBinary(string relative_path);

        // 以下为其他Helper函数，与模块开发无关，不用管
        private object RestoreType(Type original_type, object value);
        private Dictionary<string, object> ExportMemberWithAttribute(Type attribute_type);
        public override string ToString() => ModuleName;
    }
}
```

### 2. `Message`和`MessagePlain`的成员定义和详解
```CSharp
    public abstract class Message
    {
        //消息的类型. 目前能被正确处理的有Plain（纯文本消息）和At（@消息）。Ignore（空消息）会被丢弃。
        public string Type { get; } = "Ignore";
        //消息发送者的ID，也就是QQ号。如果没有特定发送者，这个字段的值是-1
        public long SenderID { get; set; }
        //消息@对象的ID，也就是QQ号。如果这条消息没有圈任何人，这个字段的值是-1
        public long TargetID { get; set; }
        //消息来源所属的群的ID，也就是群号。如果这条消息不是从群里发的（私聊），这个字段的值是-1
        //如果这条消息是群消息或者临时消息，这个字段的值是群号
        public long GroupID { get; set;  }
        //这条消息的上下文类型。目前包含私聊(Private)、群聊(Group)、临时会话(Temp)三种。
        public MessageContext Context { get; set; } 
        //一个静态对象，用来表示空消息
        //KLBot会把接收到的消息里暂时不支持的消息全部转换成空消息然后过滤掉
        public static MessageEmpty Empty = new MessageEmpty();

        //无聊的构造函数
        public Message(string type, long sender_id = -1, long group_id = -1, long target_id = -1);
    }

    public class MessagePlain : Message
    {
        //消息的文本
        public string Text { get; private set; }
        //构造函数
        public MessagePlain(long sender_id, long group_id, string text) : base("Plain", sender_id, group_id);
        //在消息的文本后追加内容
        public void AppendText(string text) => Text += text;
    }

```

### 3. 更精准的指向——只处理特定Message类型的模块基类`SingleTypeModule<T>`

* 如果你不关心这个类的来由和技术细节，可以跳过第一部分。

#### (1) 为什么需要`SingleTypeModule<T>`

在前面介绍三个基本的类的时候已经说过，`Message`类型是所有QQ消息的基类。换句话说，考虑传入模块的一条`Message`，它既可能是纯文本消息`MessagePlain`，也可能是语音消息`MessageVoice`，还可能是图像消息`MessageImage` ~~（尽管后面两种因为没用到压根还没定义）~~。

这会导致一些麻烦。

首先需要意识到，不同种类的消息本质是不一样的。虽然纯文本消息`MessagePlain`有`Text`字段，代表消息的文本内容，但显然其他类型的消息例如图像消息`MessageImage`没有这一项——即使它也是`Message`类型。

然而，就目前而言，绝大部分模块都**只**处理纯文本消息。这意味着，如果我们想写一个读取消息文本内容的模块，必然要访问`Text`字段，而`Message`基类是没有这个字段的，所以处理之前必须先把它转换成`MessagePlain`类型——但注意，传入的消息完全有可能并不是`MessagePlain`类型，这又要求转换之前还要用`is`关键字判断它的类型，如果判断结果是对不上还要另外处理，blahblah...

显然这是一件并不困难但繁琐而且没用的事情。最傻逼的是，如果我们要写二十个这样的纯文本消息处理模块，在这二十个不同的模块里，**类似这样的傻缺代码我们需要复制粘贴二十次**，可是我们想做的仅仅只是用安全的方式取一个`Text`字段而已。

> 能不能把取这个字段的操作包装成函数来避免复制粘贴呢？

这当然是可以的。但即使这样，对每个要取的特殊字段，仍然不可避免要定义一个类似的函数，这堆函数除了返回类型和访问字段不同，其他逻辑仍然完全相同。因此，用这种方法只能避免访问**同一个字段**时无意义的复制粘贴，却无法避免访问**多个字段**时的 仍然毫无意义的、对函数的复制粘贴（和轻微改动）。并且由于函数签名完全不同，**在不使用反射的情况下**，原则上不可能把这一堆复制人函数的功能统一包装成一个大函数。

至于反射......**我只是赋个值，你还想让我上反射？？？**

> 那么能不能直接把`Module`定义里处理的类型从`Message`改成`MessagePlain`呢？

这个问题的答案是，逻辑上可以改，但是从向后兼容的角度考虑不能改。因为要考虑到未来处理图像消息乃至其他种类消息的可能性，我们不能不负责任地直接假设所有`Module`处理的消息类型全部是`MessagePlain`。

> 给`Module`类加个泛型`Module<T>`，且其中`T`属于`Message`类型，然后传入消息类型改为`T`，这样总可以了吧？比如处理文本的模块，就可以直接定义为继承`Module<MessagePlain>`，这样传入参数就会自动变成`MessagePlain`了。如果以后有处理语音的模块，定义为继承`Module<MessageVoice>`即可。似乎非常完美，既避免了类型判断，又保证了向后兼容。

实际上v0.4乃至更早版本的`klbotlib`确实就是这样实现的。但是这样过早地引入泛型，会导致模块的基类各不相同。比如上面说的处理文本的模块和处理语音的模块，二者会分别属于`Module<MessagePlain>`和`Module<MessageVoice>`两个事实上不同的类型。这会导致KLBot的模块链条只能定义为对象数组，并且引发一系列连锁反应，进一步在其他地方导致各种不严谨不优雅的设计...总而言之，这种解决方案虽然可行，但是和模块轻量化的目标有**根本矛盾**——而后者恰恰是v0.5版本的更新目标。

因此，在v0.5版本更新中，新的解决方案出现了——`SingleTypeModule<T>`，其中T是Message类。这个类继承了`Module`基类，但加入了泛型。

实际上，这个解决方案和上面的最后一种方案在本质上非常相近，唯一区别只是早期方案直接在`Module`类上动手脚，而v0.5的方案则优先保持`Module`类的统一性，先用一个类继承了`Module`，然后才在这个类身上，而非`Module`类上做手脚。这小小的跳板不但比早期方案更加符合逻辑（直接在`Module`上引入泛型实际上是在假设同一个模块只能处理同一种消息，但这明显是不严谨的），还保证了所有模块最后仍能约化到`Module`这一个统一的基类上，避免了后续一切难看的连锁反应。这就是`SingleTypeModule<T>`类。

`SingleTypeModule<T>`把上面所说的所有类型判断的废话包装在类中，从而避免了那些无意义却又不可避免的复制粘贴。

<br>

#### (2) `SingleTypeModule<T>`的成员定义和详解

**如果你的模块只处理同一种类型的消息，除非你是受虐狂或者Ctrl+C/Ctrl+V爱好者，请继承`SingleTypeModule<T>`而非`Module`类**，前者可以帮你节约很多时间。其中，`T`为你的模块想要处理的消息类型，例如``MessagePlain``。

```CSharp
    public abstract class SingleTypeModule<T> : Module where T : Message
    {
        // 过滤器(T -> bool). 模块通过这个函数判断是否要处理某一条消息. 
        // 注意参数类型变成了T。这使得我们可以不用类型判断也能快乐地访问T中的字段
        public abstract bool Filter(T msg);

        // 处理器(T -> string). 模块通过这个函数处理所有(通过了过滤器的)消息. 
        // 注意参数类型变成了T。效果同上
        public abstract string Processor(T msg);

        //来自原版Module的过滤器和处理器。类型判断的废话都包装在这两个函数里面
        public sealed override bool Filter(Message msg);
        public sealed override string Processor(Message msg);

        //构造函数罢了
        public SingleTypeModule(KLBot host_bot) : base(host_bot) { }
    }
```

<br>

### 4. 模块状态和模块配置的存取
#### (1) 模块状态的保存和读取
尽管KLBot在设计时就以尽量保证持续运行时长为目标，仍然有许多问题可能导致它会重启。这时候，Bot内部模块的各种属性就会丢失。为了避免这种情况，KLBot内部设计了模块状态的自动保存和读取机制。

这就是上面代码中`[ModuleStatus]`的作用。当模块里的一个字段或者属性被打上`[ModuleStatus]`标记时，KLBot内部的**模块状态保存函数**`SaveAllModuleStatus()`会识别到这一点，每次通过这个函数保存状态到本地文件时，就会包括这个字段或者属性的值。

比如嘴臭模块有个功能是用户可以设置句子的最大长度。如果我们希望KLBot能自动保存这个值，避免每次重启都重置成默认值，只需要在这个字段上一行加上`[ModuleStatus]`。代码类似：

```CSharp
[ModuleStatus]
public int MaxLength { get; set; } = 1; //最大长度
```

这样，每当Bot调用`SaveModuleStatus()`时，这个值就会被保存到相应文件中，以供将来重启时自动读取。

> Bot会在每次处理完一批消息时调用`SaveModuleStatus()`。除此之外，Bot在有序退出（`OnExit()`）时也会调用这个函数。也就是说，模块的状态量在消息与消息之间的层级是稳定的。

> **注意：**`[ModuleStatus]`只能控制KLBot是否**保存**这个属性到状态存档文件。在读取时，无论一个字段是否标记有`[ModuleStatus]`，只要它的值出现在状态存档文件里，KLBot就会把它导入模块的相应字段中。换言之，模块里的**所有字段**都可以通过读取状态存档文件来修改。这是为了给KLBot实例的管理者提供修改模块内部字段的hack通道。

<br>

#### (2) 模块配置的保存和读取
同一个模块在不同情况下可能需要不同的配置。为了让KLBot实例的管理者有能力根据不同需求灵活地以不同方式初始化模块，同时最大程度减少源代码中出现的常量，KLBot内部还实现了**模块配置**的读取和保存机制。

和`[ModuleStatus]`类似，KLBot同样通过attribute来达成这一点。它会识别模块中负责配置的字段——`[ModuleSetup]`。当模块里的一个字段或者属性被打上`[ModuleSetup]`标记时，KLBot内部的**模块配置保存函数**`SaveModuleSetup()`会识别到这一点，每次通过这个函数保存配置到本地文件时，保存的内容里就会包含这个字段或者属性的值。

比如，开发一个小说爬虫模块时，我们希望模块的使用者可以根据自身情况把不同URL设为这个模块的爬虫出发地址。要实现这一点，只需要在相应字段上加上`[ModuleStatus]`属性：

```CSharp
[ModuleSetup]
public string BaseAddress { get; set; } //爬虫出发地址
```

这样，保存配置时，BaseAddress字段就会出现在相应的配置存档文件中。

> 因为模块配置的设计用途是初始化模块，所以KLBot不会自动保存模块配置。对KLBot实例管理员而言，配置文件可以自行编写，或者从模块开发者处获取，或者手动调用`SaveAllModuleSetup()`自动生成后再修改。

<br>

#### (3) 模块状态、模块配置的路径
模块状态和模块配置保存的文件夹均为`模块存档目录`，这个路径和之前提到的`模块私有目录`一样由KLBot.Config设置，可以通过`KLBot.Config.Pathes.ModuleSaveDir`获取。

模块状态以json形式保存在这个目录下的`“模块ID_status.json”`文件中；

模块配置以json形式保存在这个目录下的`“模块ID_setup.json”`文件中。

<br>

#### (4) 应该选择模块状态还是模块配置？二者的差别
如果你想保存、读取的是状态量，即模块运行过程中会改变的量，那么应该用`[ModuleStatus]`标记；

如果你想保存、读取的是常量或者初始值，即模块运行过程中不应该改变的量，那么应该用`[ModuleSetup]`标记。

如果你不知道它是状态量还是常量，姑且用`[ModuleStatus]`标记。

<hr>
<br>

## 四、模块开发的范例
接下来用一个简单的例子一步步演示模块开发的基本思路和流程。

考虑一个极其无聊的报时模块，它的目标功能有：

* 当有人发“报时”时，它会回复当前的时间，默认时区为UTC+8;

* 当有人发“设置时区为xx”时，它会把所报时间的时区设置为UTCxx.

<br>

### 1. 准备工作：创建文件，起名字，确定模块类型
根据**第一部分中的规范2**，模块类名应该以Module结尾。报时模块可以直译为TimeModule，简单粗暴。

有了主类名，便可以根据第一部分中的规范4，进入`项目根目录/src/modules`文件夹，新建`TimeModule.cs`文件。

根据**第一部分中的规范2**，这个类要定义在`klbotlib.Modules`命名空间中，所以在该文件中输入：
```CSharp
namespace klbotlib.Modules
{
    public class TimeModule
    {
        //...   
    }
}
```
> 简洁起见，除非有变化，否则之后不再写出命名空间。

显然，这个模块只处理纯文本消息，所以满足继承`SingleTypeModule<T>`的条件。因此，可以追加写出如下代码作为准备：

```CSharp
public class TimeModule : SingleTypeModule<MessagePlain> //MessagePlain表明该模块只处理纯文本消息
{
    //...
}
```

以上就是准备工作的全部内容了。

<br>

### 2. 核心任务：实现过滤器和处理器
之前说过，模块开发的核心任务就是定义过滤器和处理器。当然，即使不理解这一点也没有关系，因为当我们在Visual Studio中令`TimeModule`类继承`SingleTypeModule<T>`时，Visual Studio会立即标记错误，指出我们没有实现抽象成员`Filter(MessagePlain)`和`Processor(MessagePlain)`。现在就来实现这两个关键成员。

先来看过滤器`bool Filter(MessagePlain)`。

`Filter(MessagePlain)`决定了这个模块要处理哪些消息。根据上面列出的目标功能，它只处理两种消息：一种是内容是“报时”的消息，一种是内容以“设置时区为”开头的消息。对于模块要处理的消息，我们希望`Filter(MessagePlain)`能返回`true`；反之我们希望它返回`false`。这里的情况非常简单，用一个OR逻辑就可以了：

```CSharp
//用override关键字实现抽象方法
public override bool Filter(MessagePlain msg)
{
    return msg.Text == "报时" || msg.Text.StartsWith("设置时区为");
}
```

这就写好了这个模块的过滤器。当消息的内容`MessagePlain.Text`为`报时` **或者** 以`设置时区为`开头，它都会返回`true`。两者均否的情况下才会返回`false`。

接下来再看处理器`string Processor(MessagePlain)`。

`Processor(MessagePlain)`决定了这个模块如何处理每条消息。由上面写的目标功能，整个处理流程分成两种：如果内容是`报时`，则处理流程是直接返回特定时区的时间，**这个特定时区是可以被设置的**；如果内容是`设置时区为xx`，则修改模块内置的时区。

显然，修改时区的功能要求有一个字段来保存这个模块当前输出的时区是UTC几。在主类中添加定义：

```CSharp
public class TimeModule : SingleTypeModule<MessagePlain>
{
    private int time_zone = 8; //默认是UTC+8
    //...
}
```

有了这个字段，`Process(MessagePlain)`函数可以简单写为：
```CSharp
public override string Processor(MessagePlain msg)
{
    if (msg.Text == "报时")
    {
        //通过加上特定数量的小时手动计算时间。实际上有更系统的方法但是这里只举例子
        return DateTime.UtcNow.AddHours(time_zone).ToString();  
    }
    //不需要再判断“设置时区为xx”，因为能到达这里的消息其实已经经过了过滤器，不是"报时"就只剩最后一种可能性
    else    
    {
        time_zone = int.Parse(msg.Text.Substring(5));   //去掉前五个字（“设置时区为”）并转换为整数
        return $"时区已设置为UTC{time_zone:+#;-#;#}";  //"+#;-#;#"可以保证正负号除0外始终出现
    }
}
```

最后，因为`Module`基类的构造函数必须接收一个`KLBot`实例作为参数，所以所有继承它的类也必须如此，需要显式写出构造函数：
```CSharp
public TimeModule(KLBot host_bot) : base(host_bot) { }
```
> 只要继承`Module`基类就一定要写这么没用的一句，否则模块实例拿不到KLBot实例的引用。所以这个算是固定流程。

到这里，整个模块的核心功能其实就已经实现了。

此时，如果把这个模块添加到KLBot实例上，然后向机器人/机器人所监听的群里发送`报时`，会得到如下回复：

```
[TimeModule]
2021/7/22 2:13:18
```
<small>（没错，两点了👴还在写文档）</small>

如果发送`设置时区为+9`或者`设置时区为9`，机器人均会回复：

```
[TimeModule]
时区已设置为UTC+9
```
这时再发送一次`报时`，结果为：

```
[TimeModule]
2021/7/22 3:14:03
```

只需要写这么点代码，一个结果符合预期的报时模块就开发好了。

<br>

### 3.支线任务1：实现更加“用户友好”的异常处理
遗憾的是，我们并非生活在一个没人会犯错的世界里。

习惯进行*防御性编程*的人，其实应该早就对上面的

```CSharp
time_zone = int.Parse(msg.Text.Substring(5));
```

这一句代码感到非常不爽了。毕竟，我们没法保证用户总是在`设置时区为__`后面接真正的整数。谁知道他们会发些什么呢？

例如，如果有好事者向机器人发送`设置时区为abcd`，机器人将会回复以下内容：

```Log
[KLBot]
TimeModule在处理消息时崩溃。异常信息：
FormatException：Input string was not in a correct format.

调用栈：
   at System.Number.ThrowOverflowOrFormatException(ParsingStatus status, TypeCode type)
   at System.Number.ParseInt32(ReadOnlySpan`1 value, NumberStyles styles, NumberFormatInfo info)
   at System.Int32.Parse(String s)
   at klbotlib.Modules.TimeModule.Processor(MessagePlain msg)
   at klbotlib.Modules.SingleTypeModule`1.Processor(Message msg)
   at klbotlib.KLBot.ModulesProcessMessage(Message msg)
```

可以看到，将字符串`abcd`直接转换为整数的代码导致了`System.FormatException`异常，输出了上面一系列错误调试信息。

> 得益于KLBot v0.5**模块轻量化**的设计原则，单个模块出现异常不应导致整个KLBot程序崩溃，理论上，**模块内部实现导致的所有异常均会被控制在整个处理结果内**。因此，即使出现了上面这样未经模块开发者处理的异常，Bot仍然将正常工作并回复模块异常信息。这可以保证模块级别的错误不会造成Bot级别的影响。

虽然这个异常并不会导致Bot崩溃，但毕竟，返回一堆乍一看不说人话错误信息还是比较难看的。所以我们考虑加入一些常见情况的异常处理。

这里只举个简单例子。不妨继续以`设置时区为abcd`为例。如果想预先判断字符串是否可以被转换成整数，可以用`bool int.TryParse(string, out int)`函数。这个函数在能够成功转换时返回`true`并把结果写入`out int`参数，否则将返回`false`。

用这个函数，原本转换的那一行代码就可以改成：

```CSharp
//TryParse结果为true，则用out参数正常赋值即可
if (int.TryParse(msg.Text.Substring(5), out int result))    
{
    time_zone = result;
    return $"时区已设置为UTC{time_zone:+#;-#;#}";          
}
 //结果为false说明无法解析成整数，这时候返回其他消息提示
else
    return $"错误：你输了什么狗屁东西？";
```

几行修改之后，再发送`设置时区为abcd`，就会得到如下回复：

```
[TimeModule]
错误：你输了什么狗屁东西？
```

这样观感就会比Bot自动打印的那一串异常调试信息会好得多。

<br>

### 4-1.支线任务2-1：配置的读取
现在让我们再考虑一个刻意得不切实际的场景。

为了举例，下面假设：

* 我们正在开发的模块只是一个单纯的报时模块，只能处理`报时`消息，并没有设置时区功能；

* 这个弱智报时模块非常成功，以至于一举开拓国际市场(?)，很多国际友人也想使用。

在这种场景下，默认时区为UTC+8的这个设定就不太好了。毕竟，如果这个模块的海外用户想知道时间，还要自己做点加减。

> 直接修改源码里的初始值可以吗？

当然可以，但是一份源码**总会有个初始值**。如果保持只有一份源码，改成美国时间，美国之外的用户就又得做加减了，这样没解决根本问题；如果为每一个时区都准备一份源码，大家会觉得你是个憨憨。

似乎只有开发上面已经实现了的`设置时区为XX`的功能才能解决这个问题？

其实不然。注意到，时区的初始值`+8`或者`-7`正好在**第二部分第4条**说过的“常量或初始值”之列。这意味着我们可以通过模块配置`[ModuleSetup]`这个attribute来解决这个问题。

我们可以把这个无法改变的常量通过这种方法配置化，让它变成可以通过外部配置文件修改的值。这样，既能保证模块在**不同**环境下**部署的灵活性**，又能保证模块在**相同**环境下**行为的一致性**。

对模块开发者而言，实现上面这一点只需要在我们想配置文件化的字段上方加上这个标记：

```CSharp
public class TimeModule : SingleTypeModule<MessagePlain>
{
    [ModuleSetup]  //加上这玩意
    private int time_zone = 8; 
    //...
}
```

这样，尽管源码上默认值仍然是8，但不同地区的人员可以通过修改`模块ID_setup.json`里的值来修改这个值。Bot会在每次启动时自动加载这个文件。

例如，`TimeModule_setup.json`中的内容如下：

```javascript
{
  "$type": "System.Collections.Generic.Dictionary`2[[System.String, System.Private.CoreLib],[System.Object, System.Private.CoreLib]], System.Private.CoreLib",  //$type为Json库产生的类型信息，（一般）不需要关心
  "time_zone": 11    //修改这个值即可修改默认时区
}
```

此时启动KLBot，发送`报时`，得到回复如下：

```
[TimeModule]
2021/7/22 14:28:01
```

而此时北京时间为11:28。模块返回的确实是UTC+11的时间。

> 注意：模块配置文件用模块的ID作为区分（目前(v0.5)文件名为`模块ID_setup.json`），因此同一种模块的不同实例（比如消息链条里有两个`TimeModule`）不会共享配置文件，可以安全使用。

<br>

### 4-2.支线任务2-2：状态的自动保存和读取
现在从前面的国际化架空场景中跳回我们的实现。

实际上，整个模块在各种情况下的运行结果就都已经达到预期，很令人满意了。但是，当KLBot实例由于某些原因重启之后，一个恼人的问题就会出现：每次重启，之前设置好的时区会自动重置成代码里的默认值（也就是+8）。好在，利用之前在**第二部分第4条**介绍过的`[ModuleStatus]`attribute，可以方便快捷地实现特定字段的自动存取。

只需要在我们想自动保存的字段上方加上这个标记：

```CSharp
public class TimeModule : SingleTypeModule<MessagePlain>
{
    [ModuleStatus]  //加上这玩意
    private int time_zone = 8; 
    //...
}
```

这样，每次处理新的非空消息，KLBot都会把模块的状态保存到本地文件中，以供下次重启时读取载入。

> 模块状态存档文件用模块的ID作为区分（目前(v0.5)文件名为`模块ID_status.json`），因此同一种模块的不同实例（比如消息链条里有两个`TimeModule`）不会共享状态存档文件。

<br>


